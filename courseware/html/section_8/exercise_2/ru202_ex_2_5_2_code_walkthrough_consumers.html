<h2>THE CONSUMERS</h2>
<p>Each consumer runs as a separate process, and is created using the <span style="font-family: 'courier new', courier;">new_consumer</span> function at line 91.  This simply starts a new process using the function <span style="font-family: 'courier new', courier;">consumer_func</span> as its entry point.</p>
<p>The real work of the consumer is carried out in <span style="font-family: 'courier new', courier;">consumer_func</span> (line 39 onwards).  The consumer starts in "recovery" mode, and sets the initial message ID to read from (<span style="font-family: 'courier new', courier;">from_id</span>) to <span style="font-family: 'courier new', courier;">0</span> in order to process any backlog in its pending entry list before asking for new messages.  This is to ensure that when the consumer is terminated and restarted by the chaos function, it can pick up from where it left off.</p>
<p>The consumer enters an infinite loop at line 47, in which it first picks a random number (1 - 5) of messages to request from the stream, using a blocking <span style="font-family: 'courier new', courier;">XREADGROUP</span> command to request these at line 49.  If the response from Redis contains no messages, then the consumer enters a wait / retry block at line 50.  It will periodically retry to read more messages with longer blocking timeouts until eventually giving up if none are produced.  In practice, this won’t happen unless we change the code to kick off a larger number of consumers, so that they eventually work faster than the producer.</p>
<p>If the consumer is in "recovery" mode (it was just started, or re-started and is reading messages from its pending entry list beginning from ID 0), and there are messages to recover then it will process those starting at line 74.  If there were no messages, the consumer comes out of "recovery" mode at line 79 and updates <span style="font-family: 'courier new', courier;">from_id</span> to be <span style="font-family: 'courier new', courier;">&gt;</span> so that it will request new messages having exhausted those on its pending entry list.</p>
<p>The work of processing each message is carried out beginning at line 84, where the number stored in the message’s <span style="font-family: 'courier new', courier;">n</span> key is obtained and passed to the prime function to determine whether or not it is prime.</p>
<p>Having processed the message, the consumer then acknowledges it using <span style="font-family: 'courier new', courier;">XACK</span> at line 89, removing the message from that consumer’s pending entry list.</p>