0
00:00:00,000 --> 00:00:00,500


1
00:00:00,500 --> 00:00:02,660
Let's now take a moment to look at some performance

2
00:00:02,660 --> 00:00:06,120
considerations when working with Redis streams.

3
00:00:06,120 --> 00:00:08,039
We'll review the big O complexity

4
00:00:08,039 --> 00:00:10,740
of some common streams commands and take a peek

5
00:00:10,740 --> 00:00:12,480
under the hood to see how streams

6
00:00:12,480 --> 00:00:15,580
are implemented in Redis.

7
00:00:15,580 --> 00:00:18,190
The only way to add messages to a Redis stream

8
00:00:18,190 --> 00:00:20,920
is by using the XADD command.

9
00:00:20,920 --> 00:00:24,940
As we have seen XADD places new messages into the stream

10
00:00:24,940 --> 00:00:26,710
by appending them.

11
00:00:26,710 --> 00:00:29,920
No other insertion strategies are available.

12
00:00:29,920 --> 00:00:35,070
So we can think of a stream as an append only log.

13
00:00:35,070 --> 00:00:40,020
XADD has a time complexity of O of one, or constant time.

14
00:00:40,020 --> 00:00:43,410
This means that we can expect XADD's performance

15
00:00:43,410 --> 00:00:45,750
to remain the same regardless of whether we

16
00:00:45,750 --> 00:00:48,720
are adding the first, hundredth, or 10 millionth

17
00:00:48,720 --> 00:00:51,040
message to a stream.

18
00:00:51,040 --> 00:00:53,980
In a streaming system it's important for data ingestion

19
00:00:53,980 --> 00:00:57,670
to run in constant time because of the potentially large volume

20
00:00:57,670 --> 00:00:58,840
of data.

21
00:00:58,840 --> 00:01:02,650
Producers need to be able to add new messages into the stream

22
00:01:02,650 --> 00:01:07,780
at rates not affected by the overall length of the stream.

23
00:01:07,780 --> 00:01:09,580
When reading data from the stream

24
00:01:09,580 --> 00:01:12,610
it's also desirable to be able to fetch one or more messages

25
00:01:12,610 --> 00:01:15,250
from it with predictable performance,

26
00:01:15,250 --> 00:01:18,520
ensuring consistent consumer experience regardless

27
00:01:18,520 --> 00:01:22,420
of the streams length or the position of the messages in it.

28
00:01:22,420 --> 00:01:25,060
When consuming from the end of the stream using

29
00:01:25,060 --> 00:01:28,330
XREAD or XREADGROUP it should come as no surprise

30
00:01:28,330 --> 00:01:31,290
that their performance is constant.

31
00:01:31,290 --> 00:01:34,710
However, the fact that their performance remains constant

32
00:01:34,710 --> 00:01:36,510
when reading from arbitrary positions

33
00:01:36,510 --> 00:01:41,130
in the middle of the stream, is perhaps more noteworthy.

34
00:01:41,130 --> 00:01:44,460
This holds not only for XREAD and XREADGROUP,

35
00:01:44,460 --> 00:01:48,510
but also for the XRANGE and XDEL commands.

36
00:01:48,510 --> 00:01:50,730
Each of these commands is able to access

37
00:01:50,730 --> 00:01:53,010
any message in a stream with constant time

38
00:01:53,010 --> 00:01:55,440
performance because of the way that Redis streams are

39
00:01:55,440 --> 00:01:56,880
implemented.

40
00:01:56,880 --> 00:01:59,070
Let's take a look into that now.

41
00:01:59,070 --> 00:02:01,320
Now, it's convenient to think of a Redis stream

42
00:02:01,320 --> 00:02:04,530
as an append only log, but if streams were implemented

43
00:02:04,530 --> 00:02:08,039
as an append only log then many of these read operations

44
00:02:08,039 --> 00:02:10,960
would have a time complexity of O of N.

45
00:02:10,960 --> 00:02:13,830
So how is it that with Redis streams such operations

46
00:02:13,830 --> 00:02:16,640
trend towards O of 1?

47
00:02:16,640 --> 00:02:18,590
It turns out that the Redis stream data

48
00:02:18,590 --> 00:02:21,440
structure is implemented as a radix tree,

49
00:02:21,440 --> 00:02:26,060
an optimized trie often used to implement sets and associative

50
00:02:26,060 --> 00:02:28,440
arrays.

51
00:02:28,440 --> 00:02:32,850
The radix tree works by encoding keys as a set of paths

52
00:02:32,850 --> 00:02:35,250
through the tree's nodes, with leaves

53
00:02:35,250 --> 00:02:39,230
at the bottom representing a single key's value.

54
00:02:39,230 --> 00:02:41,510
When keys share common substrings

55
00:02:41,510 --> 00:02:45,020
they can be merged into a single node to save space.

56
00:02:45,020 --> 00:02:49,290
This technique is called path compression.

57
00:02:49,290 --> 00:02:53,310
Here we see how a series of IDs generated by XADD

58
00:02:53,310 --> 00:02:56,040
might be represented in a radix tree

59
00:02:56,040 --> 00:02:59,250
and how path compression can help reduce the number of nodes

60
00:02:59,250 --> 00:03:01,420
required in the tree.

61
00:03:01,420 --> 00:03:04,930
Common parts of the key names are merged into single nodes

62
00:03:04,930 --> 00:03:07,240
with each leaf node containing a pointer

63
00:03:07,240 --> 00:03:10,290
to the message payload values.

64
00:03:10,290 --> 00:03:14,350
When searching a radix tree the time complexities O of M,

65
00:03:14,350 --> 00:03:18,330
where M represents the length of the key being searched for.

66
00:03:18,330 --> 00:03:22,410
In Redis streams key lengths, that is the message IDs,

67
00:03:22,410 --> 00:03:26,190
are generally constant in length and also relatively short.

68
00:03:26,190 --> 00:03:29,580
This means that all lookups have constant time complexity, which

69
00:03:29,580 --> 00:03:30,840
can be reduced to O of 1.

70
00:03:30,840 --> 00:03:33,350


71
00:03:33,350 --> 00:03:35,600
One thing to keep in mind however,

72
00:03:35,600 --> 00:03:38,630
even though locating a key is an O of 1 operation,

73
00:03:38,630 --> 00:03:41,470
scanning from that key onwards is still

74
00:03:41,470 --> 00:03:44,650
O of N on the number of messages returned.

75
00:03:44,650 --> 00:03:47,500
For example, running an XRANGE command

76
00:03:47,500 --> 00:03:49,750
with a counter argument of a million

77
00:03:49,750 --> 00:03:52,160
is still O of a million.

78
00:03:52,160 --> 00:03:55,300
So in general be careful with the count argument when running

79
00:03:55,300 --> 00:03:59,030
XRANGE, XREAD, and XREADGROUP.

80
00:03:59,030 --> 00:04:00,910
It's hard to make a rule of thumb here,

81
00:04:00,910 --> 00:04:04,010
but if you need more than 1,000 messages returned,

82
00:04:04,010 --> 00:04:07,300
it's probably best to break this into multiple calls.

83
00:04:07,300 --> 00:04:10,510
Anecdotally, when I try returning a million messages

84
00:04:10,510 --> 00:04:14,540
from a stream on my local machine it takes 90 seconds.

85
00:04:14,540 --> 00:04:17,950
And that's a long time for a Redis server to be blocked.

86
00:04:17,950 --> 00:04:21,220
Anyway if you'd like to learn more about this specific radix

87
00:04:21,220 --> 00:04:23,860
tree implementation used for Redis streams,

88
00:04:23,860 --> 00:04:26,470
check out the RAX project on GitHub,

89
00:04:26,470 --> 00:04:28,550
which is a standalone implementation of it.

90
00:04:28,550 --> 00:04:31,210


91
00:04:31,210 --> 00:04:32,880
So what's the upshot here?

92
00:04:32,880 --> 00:04:35,520
Well, unlike an actual append only log,

93
00:04:35,520 --> 00:04:38,430
fetching or deleting an ID from your Redis stream

94
00:04:38,430 --> 00:04:40,890
is a constant time operation.

95
00:04:40,890 --> 00:04:42,450
This is because Redis streams are

96
00:04:42,450 --> 00:04:45,090
implemented using radix trees.

97
00:04:45,090 --> 00:04:48,120
Any operation that involves seeking to a particular point

98
00:04:48,120 --> 00:04:50,540
in the stream is O of 1.

99
00:04:50,540 --> 00:04:54,020
But still be careful to avoid returning thousands of messages

100
00:04:54,020 --> 00:04:56,270
or more in a single call.

101
00:04:56,270 --> 00:04:59,300
This is expensive no matter what the underlying data structure

102
00:04:59,300 --> 00:05:01,300
you use.

103
00:05:01,300 --> 00:05:03,760
But overall you have a lot more flexibility

104
00:05:03,760 --> 00:05:05,500
in reading your Redis stream than you

105
00:05:05,500 --> 00:05:08,530
have in scanning a traditional append only log

106
00:05:08,530 --> 00:05:10,180
and you can use this to your advantage

107
00:05:10,180 --> 00:05:13,590
when designing Redis streams applications.

